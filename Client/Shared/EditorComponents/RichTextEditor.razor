@using HybridPages.Client.State;
@using HybridPages.Shared.Enums;
@using HybridPages.Shared.Models.TextEditor;
@using System.Text.RegularExpressions;
@inject PageService _pageService;
@page "/richtexteditor"
<button class="@(SelectionFormatContains(FormatBlockTypeEnum.B) ? "format-button-selected" : "")" @onclick="@(() => FormatItem(FormatBlockTypeEnum.B))">B</button>
<button class="@(SelectionFormatContains(FormatBlockTypeEnum.I) ? "format-button-selected" : "")" @onclick="@(() => FormatItem(FormatBlockTypeEnum.I))"><i>I</i></button>
<button class="@(SelectionFormatContains(FormatBlockTypeEnum.U) ? "format-button-selected" : "")" @onclick="@(() => FormatItem(FormatBlockTypeEnum.U))"><u>U</u></button>
<div tabindex="0" style="background-color: white" @onkeydown="KeyDown" @ref="inputBoxRef" class="rich-text-editor-container" @onmousedown:preventDefault @onmouseup="SelectionEnd" @onpointerleave="SelectionEnd" @onmouseup:preventDefault>
	@{
		loopIndex = 0;
	}
	@foreach (var character in ContentArray)
	{
		int i = loopIndex;
		<span class="text-cursor-shift @((selectionStart <= i && i <= selectionEnd) || (selectionEnd <= i && i <= selectionStart) ? "selection-highlight" : "")" @onclick="() => MoveCursor(i)" @onmousedown="() => SelectionStart(i)" @onmouseenter="(e) => SelectionAdd(i, e)" @onmouseup="SelectionEnd" @onmousedown:preventDefault @onmouseup:preventDefault>
			@switch (character.Format)
			{
				case FormatBlockTypeEnum.None:
					@character.Content
					break;
				case FormatBlockTypeEnum.I:
					<i>@character.Content</i>
					break;
				case FormatBlockTypeEnum.B:
					<b>@character.Content</b>
					break;
				case FormatBlockTypeEnum.U:
					<u>@character.Content</u>
					break;
				case FormatBlockTypeEnum.I | FormatBlockTypeEnum.U:
					<i><u>@character.Content</u></i>
					break;
				case FormatBlockTypeEnum.B | FormatBlockTypeEnum.U:
					<b><u>@character.Content</u></b>
					break;
				case FormatBlockTypeEnum.I | FormatBlockTypeEnum.B:
					<i><b>@character.Content</b></i>
					break;
				case FormatBlockTypeEnum.I | FormatBlockTypeEnum.B | FormatBlockTypeEnum.U:
					<i><b><u>@character.Content</u></b></i>
					break;
			}
		</span>

		@if (i == _cursorIndex)
		{
			<div class="text-cursor"></div>
		}
		loopIndex++;
	}
</div>
@*@_cursorIndex
@foreach (var entry in log)
{
	<p>@entry</p>
}*@


@code {
	public string Content { get; set; } = "Testing123";
	public List<List<FormatBlock>> Paragraphs { get; set; } = new List<List<FormatBlock>>();
	public List<FormatBlock> ContentArray { get; set; }
	private int _cursorIndex { get; set; }
	private List<string> log { get; set; } = new();
	public int loopIndex { get; set; }
	public int formatBlockIndex { get; set; }
	private ElementReference inputBoxRef { get; set; }
	private int? selectionStart { get; set; }
	private int? selectionEnd { get; set; }
	private bool isMouseDown { get; set; } = false;

	private string _alphaNumericCharacterPattern = "^[a-zA-Z0-9.,@£$%!?&*^()\\[\\]\\/{} ]$";

	protected override async Task OnInitializedAsync()
	{
		ContentArray = Content.ToCharArray().Select(i => new FormatBlock { Content = i.ToString() }).ToList();
		_cursorIndex = ContentArray.Count() - 1;
	}

	private bool SelectionFormatContains(FormatBlockTypeEnum formatFlag)
	{
		int anchorValue;

		if (selectionStart != null && selectionEnd != null)
		{
			anchorValue = Math.Min(selectionStart.Value, selectionEnd.Value);
		}
		else
		{
			anchorValue = _cursorIndex;
		}
		if ((ContentArray[anchorValue].Format & formatFlag) != 0)
		{
			return true;
		}
		else
		{
			return false;
		}
	}

	private void FormatItem(FormatBlockTypeEnum formatFlag)
	{
		if (selectionStart != null && selectionEnd != null)
		{
			var lowerValue = Math.Min(selectionStart.Value, selectionEnd.Value);
			var higherValue = Math.Max(selectionStart.Value, selectionEnd.Value);
			var selectionCount = higherValue - lowerValue + 1;

			var flagAdded = false;
			var flagRemoved = false;

			if ((ContentArray[lowerValue].Format & formatFlag) == 0)
			{
				ContentArray[lowerValue].Format |= formatFlag;
				flagAdded = true;
			}
			else
			{
				ContentArray[lowerValue].Format &= ~formatFlag;
				flagRemoved = true;
			}

			foreach (var formatBlock in ContentArray.GetRange(lowerValue, selectionCount))
			{
				if ((formatBlock.Format & formatFlag) == 0 && flagAdded)
				{
					formatBlock.Format |= formatFlag;
				}
				else if ((formatBlock.Format & formatFlag) != 0 && flagRemoved)
				{
					formatBlock.Format &= ~formatFlag;
				}
			}
			MoveCursor(higherValue);
		}
	}

	private async Task SelectionStart(int index)
	{
		selectionEnd = null;
		isMouseDown = true;
		await inputBoxRef.FocusAsync();
		selectionStart = index;
		log.Add($"selection started: {index}");
		StateHasChanged();
	}
	private async Task SelectionAdd(int index, MouseEventArgs e)
	{
		if (selectionStart != null && isMouseDown)
		{
			selectionEnd = index;
			log.Add($"selection to: {index}");
			if (selectionStart.Value < selectionEnd.Value)
			{
				MoveCursor(index);
			}
			else
			{
				MoveCursor(index - 1);
			}
			StateHasChanged();
		}
	}

	private async Task SelectionEnd()
	{
		isMouseDown = false;
		await inputBoxRef.FocusAsync();
		log.Add($"selection ended: {selectionStart} -> {selectionEnd}");
		StateHasChanged();
	}

	private async Task KeyDown(KeyboardEventArgs e)
	{
		bool deleted;
		switch (true)
		{
			case bool _ when Regex.IsMatch(e.Key, _alphaNumericCharacterPattern):

				ContentArray.Insert(_cursorIndex + 1, new FormatBlock { Content = e.Key });
				_cursorIndex++;
				if (selectionStart != null && selectionEnd != null)
				{
					selectionStart++;
					selectionEnd++;
					deleted = DeleteSelection();
				}
				break;
			case bool _ when e.Key == "Enter":

				break;
			case bool _ when e.Key == "Backspace":
				deleted = DeleteSelection();
				if (!deleted && _cursorIndex >= 0)
				{
					ContentArray.RemoveAt(_cursorIndex);
					_cursorIndex--;
				}
				break;
			case bool _ when e.Key == "Delete":
				deleted = DeleteSelection();
				if (!deleted && _cursorIndex < ContentArray.Count() - 1)
				{
					ContentArray.RemoveAt(_cursorIndex + 1);
				}
				break;
			case bool _ when e.Key == "ArrowLeft":
				if (_cursorIndex >= 0)
					_cursorIndex--;
				break;
			case bool _ when e.Key == "ArrowRight":
				if (_cursorIndex < ContentArray.Count() - 1)
					_cursorIndex++;
				break;
			default:

				break;
		}
		selectionStart = selectionEnd = null;
		StateHasChanged();
	}

	private bool DeleteSelection()
	{
		if (selectionStart != null && selectionEnd != null)
		{
			var lowerValue = Math.Min(selectionStart.Value, selectionEnd.Value);
			var higherValue = Math.Max(selectionStart.Value, selectionEnd.Value);
			var selectionCount = higherValue - lowerValue + 1;
			ContentArray.RemoveRange(lowerValue, selectionCount);
			MoveCursor(lowerValue - 1);
			selectionStart = selectionEnd = null;
			return true;
		}
		return false;
	}

	private async void MoveCursor(int index)
	{
		await inputBoxRef.FocusAsync();
		_cursorIndex = index;
		//log.Add($"index selected: {index}");
		StateHasChanged();
	}
}