@page "/backgrounddesigner"
@using HybridPages.Shared.Helpers;
@using HybridPages.Shared.Models.Styling;
@inject DOMElements DOMElements;

<div class="background-designer" style="@backgroundCss" @onmousemove="(args) => MouseMove(args)" @onmouseup="(args) => MouseUp(args)" @onmousedown="MouseDown">

	<div class="fixed-debug">
	</div>

	@foreach (var colourPoint in backgroundMesh.ColourPoints)
	{
		<div @onmousedown="() => SelectColourPoint(colourPoint)" @onmousedown:preventDefault="true" class="draggable-circle @(colourPoint == _colourPoint ? "draggable-circle-highlighted" : "")" style="background-color: hsl(@colourPoint.H, @colourPoint.S%, @colourPoint.L%, @colourPoint.A%); left: @(colourPoint.HPosAbs-10)px; top: @(colourPoint.VPosAbs-10)px">
		</div>
	}
	@if (_colourPoint != null)
	{
		<div class="colour-settings" @onmousedown="() => ColourSettingsActive(true)" @onmouseup="() => ColourSettingsActive(false)">
			<div class="slider-row">
				<div class="slider-label">
					H
				</div>
				<div class="slider-component">
					<input type="range" id="h" class="slider-hue" name="h" min="0" max="360" @bind-value="_colourPoint.H" @bind-value:event="oninput">
				</div>
				<div class="slider-value">
					@_colourPoint.H
				</div>
			</div>
			<div class="slider-row">
				<div class="slider-label">
					S
				</div>
				<div class="slider-component">
					<input type="range" id="s" name="s" class="slider-saturation" style="background: linear-gradient(to right, hsla(@(_colourPoint.H), 0%, 50%, 1), hsla(@(_colourPoint.H), 100%, 50%, 1))" min="0" max="100" @bind-value="_colourPoint.S" @bind-value:event="oninput">
				</div>
				<div class="slider-value">
					@_colourPoint.S
				</div>
			</div>
			<div class="slider-row">
				<div class="slider-label">
					L
				</div>
				<div class="slider-component">
					<input type="range" id="l" class="slider-lightness" style="background: linear-gradient(to right, hsla(@(_colourPoint.H), 100%, 0%, 1), hsla(@(_colourPoint.H), 100%, 50%, 1), hsla(@(_colourPoint.H), 100%, 100%, 1))" name="l" min="0" max="100" @bind-value="_colourPoint.L" @bind-value:event="oninput">
				</div>
				<div class="slider-value">
					@_colourPoint.L
				</div>
			</div>
			<div class="slider-row">
				<div class="slider-label">
					A
				</div>
				<div class="slider-component">
					<input type="range" id="a" name="a" min="0" max="1" @bind-value="_colourPoint.A" step="0.01" @bind-value:event="oninput">
				</div>
				<div class="slider-value">
					@_colourPoint.A
				</div>
			</div>
			<div class="layer-row">
				Foreground / Background:
			</div>
			<div class="slider-row">
				<div class="slider-label">
					
				</div>
				<div class="slider-component">
					<input type="range" id="layerHeight" name="layerHeight" min="1" max="7" @bind-value="_colourPoint.LayerHeight" @bind-value:event="oninput" step="0.0001">
				</div>
				<div class="slider-value">
					
				</div>
			</div>
		</div>
	}
</div>

@code {
	private BackgroundMesh backgroundMesh = new();
	private WindowDimensions windowDimensions = new WindowDimensions { Height = 0, Width = 0 };
	private string backgroundCss = "test";
	private double mousex = 0;
	private double mousey = 0;
	private RadialGradient? _colourPoint;
	private bool _dragging = false;
	private bool _colourSettingsActive = false;

	protected override async Task OnInitializedAsync()
	{
		backgroundMesh = new BackgroundMesh
			{
				BackgroundColour = new RadialGradient { HPosPercent = 0, VPosPercent = 0, H = 237, S = 100, L = 50, A = 1, Alpha = 100 },
				ColourPoints = new List<RadialGradient>
			{
				new RadialGradient {HPosPercent = 55, VPosPercent = 68, H = 228, S = 40, L = 83, A = 1, Alpha = 50, LayerHeight = 1},
				new RadialGradient {HPosPercent = 38, VPosPercent = 31, H = 200, S = 100, L = 50, A = 0.84f, Alpha = 50, LayerHeight = 2},
				new RadialGradient {HPosPercent = 24, VPosPercent = 60, H = 310, S = 95, L = 60, A = 1, Alpha = 50, LayerHeight = 3},
				new RadialGradient {HPosPercent = 67, VPosPercent = 41, H = 100, S = 95, L = 62, A = 1, Alpha = 50, LayerHeight = 4},
				new RadialGradient {HPosPercent = 0, VPosPercent = 100, H = 100, S = 0, L = 73, A = 1, Alpha = 50, LayerHeight = 5},
				new RadialGradient {HPosPercent = 80, VPosPercent = 100, H = 201, S = 57, L = 76, A = 1, Alpha = 50, LayerHeight = 6},
				new RadialGradient {HPosPercent = 15, VPosPercent = 20, H = 258, S = 100, L = 11, A = 1, Alpha = 50, LayerHeight = 7}
			}
			};
		RenderBackground();
		UpdateColourPoints();

		var timer = new PeriodicTimer(TimeSpan.FromSeconds(1));

		while (await timer.WaitForNextTickAsync())
		{
			windowDimensions = await DOMElements.GetWindowDimensions();
		}
	}

	public void RenderBackground()
	{
		backgroundCss = $"background-color: {GetHSLACss(backgroundMesh.BackgroundColour)};";
		backgroundCss += $"background-image: ";

		foreach (var colourPoint in backgroundMesh.ColourPoints.OrderBy(c => c.LayerHeight))
		{
			backgroundCss += $"radial-gradient(at {colourPoint.HPosPercent}% {colourPoint.VPosPercent}%, {GetHSLACss(colourPoint)} 0px, transparent {colourPoint.Alpha}%),";
		}
		backgroundCss = backgroundCss.Remove(backgroundCss.Length - 1, 1) + ";";
		StateHasChanged();
	}

	public string GetHSLACss(RadialGradient sourceColourPoint)
	{
		return $"hsla({sourceColourPoint.H}, {sourceColourPoint.S}%, {sourceColourPoint.L}%, {sourceColourPoint.A})";
	}

	public void SelectColourPoint(RadialGradient colourPoint)
	{
		_colourPoint = colourPoint;
	}
	public void MouseDown()
	{
		if (!_colourSettingsActive)
		{
			_dragging = true;
		}

	}

	public async void MouseMove(MouseEventArgs args)
	{
		if (_dragging && _colourPoint != null)
		{
			_colourPoint.HPosAbs = Convert.ToInt32(Math.Round(_colourPoint.HPosAbs + args.MovementX));
			_colourPoint.VPosAbs = Convert.ToInt32(Math.Round(_colourPoint.VPosAbs + args.MovementY));

			windowDimensions = await DOMElements.GetWindowDimensions();

			_colourPoint.HPosPercent = Convert.ToInt32(Math.Round(_colourPoint.HPosAbs / (double)windowDimensions.Width * 100));
			_colourPoint.VPosPercent = Convert.ToInt32(Math.Round(_colourPoint.VPosAbs / (double)windowDimensions.Height * 100));
		}
		StateHasChanged();
		RenderBackground();
	}

	public void MouseUp(MouseEventArgs args)
	{
		_dragging = false;
	}

	public void ColourSettingsActive(bool active)
	{
		_colourSettingsActive = active;
	}

	public async void UpdateColourPoints()
	{
		windowDimensions = await DOMElements.GetWindowDimensions();

		foreach (var colourPoint in backgroundMesh.ColourPoints)
		{
			colourPoint.HPosAbs = Convert.ToInt32(Math.Round((double)colourPoint.HPosPercent / 100 * windowDimensions.Width, 0));
			colourPoint.VPosAbs = Convert.ToInt32(Math.Round((double)colourPoint.VPosPercent / 100 * windowDimensions.Height, 0));
		}

		StateHasChanged();
	}


}
